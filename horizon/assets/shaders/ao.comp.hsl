#include "include/translation/translation.h"
#define USE_SSAO
#include "include/ao/ssao.h"
#include "include/common/noise.hsl"

// 

RES(Tex2D(float4), depth_tex, UPDATE_FREQ_PER_FRAME, t0, binding = 0);
RES(Tex2D(float4), normal_tex, UPDATE_FREQ_PER_FRAME, t1, binding = 1);
RES(Tex2D(float2), ssao_noise_tex, UPDATE_FREQ_PER_FRAME, t2, binding = 2);
RES(SamplerState, default_sampler, UPDATE_FREQ_PER_FRAME, s0, binding = 3);
RES(RWTex2D(float4), ao_factor_tex, UPDATE_FREQ_PER_FRAME, u0, binding = 4);

#ifdef USE_SSAO
CBUFFER(SSAOConstant, UPDATE_FREQ_PER_FRAME, b1, binding = 5)
{
    DATA(float4x4, camera_projection, None);
    DATA(float4x4, camera_inv_projection, None);
    DATA(float4x4, camera_view, None);
    DATA(uint2, resolution, None);
    DATA(float2, noise_scale, None);
    DATA(float4, kernels[SSAO_SAMPLE_COUNT], None); // tangent space kernels
};
#endif

NUM_THREADS(8, 8, 1)
void CS_MAIN( SV_DispatchThreadID(uint3) threadID) 
{
    INIT_MAIN;

    uint2 _resolution = Get(resolution.xy) - uint2(1.0, 1.0);

    if(threadID.x>_resolution.x || threadID.y>_resolution.y) {
        RETURN();
    }

    float2 uv = float2(threadID.xy) / float2(_resolution);

    float depth = SampleTex2D(Get(depth_tex), default_sampler, uv).r;
    float3 view_pos = ReconstructWorldPos(Get(camera_inv_projection), depth, uv);

    float3 normal = SampleTex2D(Get(normal_tex), default_sampler, uv).xyz;
    float3 view_normal = mul(float4(normal, 0.0), Get(camera_view)).xyz; // view space normal

    float ao_factor = 0.0;

#ifdef USE_SSAO
    float2 noise_uv = uv * Get(noise_scale).xy;

    float3 rvec = float3(SampleTex2D(Get(ssao_noise_tex), default_sampler, noise_uv).xy, 0.0) * 2.0 - 1.0;;
    float3 tangent = normalize(rvec - view_normal * dot(rvec, view_normal));
	float3 bitangent = cross(tangent, view_normal);
	float3x3  tbn = make_f3x3_rows(tangent, bitangent, view_normal);

    for (uint i = 0; i < SSAO_SAMPLE_COUNT; i++){
        float3 sample_pos = view_pos + mul(Get(kernels)[i].xyz, tbn) * SSAO_SAMPLE_RADIUS;

        float4 offset = mul(float4(sample_pos, 1.0), Get(camera_projection));
        offset.xyz /= offset.w;
        offset.xy = offset.xy * 0.5 + 0.5;
        offset.y = 1.0 - offset.y;

        float sample_z = SampleTex2D(Get(depth_tex), default_sampler, offset.xy).r;
        // we need to compare depth in linear space
        float linearZ = ReconstructWorldPos(Get(camera_inv_projection), sample_z, offset.xy).z;
        // occluded
        float range_falloff = lerp(0.0, 1.0, SSAO_SAMPLE_RADIUS / abs(linearZ - view_pos.z)); // closer samples contribute more occlusion
        if(linearZ >= sample_pos.z + SSAO_BIAS) {
            ao_factor += range_falloff * 1.0f;
        }
    }

    ao_factor /= SSAO_SAMPLE_COUNT;
    ao_factor = 1.0 - ao_factor;
#endif
    float4 out_color = float4(ao_factor, 0.0, 0.0, 0.0);

    Write2D(Get(ao_factor_tex), threadID.xy, out_color);

    RETURN();
}

