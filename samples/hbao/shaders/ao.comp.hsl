#include "include/translation/translation.h"
#include "include/common/common_math.h"

#define SSAO_SAMPLE_COUNT 32
#define SSAO_SAMPLE_RADIUS 1.0
#define SSAO_BIAS 0.025

#define NUM_MARCH_DIRECTIONS 8
#define NUM_MARCH_STEPS 4
#define HBAO_TEX_RES 4
#define HBAO_SCALE 1.0
#define AO_METHOD_SSAO 0
#define AO_METHOD_HBAO 1
// 

RES(Tex2D(float4), depth_tex, UPDATE_FREQ_PER_FRAME, t0, binding = 0);
RES(Tex2D(float4), normal_tex, UPDATE_FREQ_PER_FRAME, t1, binding = 1);
RES(Tex2D(float2), ssao_noise_tex, UPDATE_FREQ_PER_FRAME, t2, binding = 2);
RES(SamplerState, default_sampler, UPDATE_FREQ_PER_FRAME, s0, binding = 3);
RES(RWTex2D(float4), ao_factor_tex, UPDATE_FREQ_PER_FRAME, u0, binding = 4);
RES(Tex2D(float4), hbao_rand_tex, UPDATE_FREQ_PER_FRAME, t2, binding = 6);

CBUFFER(AOConstant, UPDATE_FREQ_PER_FRAME, b1, binding = 5)
{
    DATA(float4x4, camera_projection, None);
    DATA(float4x4, camera_inv_projection, None); // we only care about view space
    DATA(float4x4, camera_view, None);
    DATA(uint2, resolution, None);
    DATA(float2, noiseScale, None);
    DATA(float, g_RadiusToScreen, None);
    DATA(float, g_NDotVBias, None);
    DATA(float, g_NegInvR2, None);
    DATA(uint, aoMethod, None);
    DATA(float4, kernels[SSAO_SAMPLE_COUNT], None); // tangent space kernels
};

float SSAO(float3 pos_vs, float3 normal_vs, float2 uv) {

    float nom = 0.0;
    float2 noiseUv = uv * Get(noiseScale).xy;
    float3 rvec = float3(
        SampleTex2D(Get(ssao_noise_tex), default_sampler, noiseUv).xy, 0.0);
    float3 tangent = normalize(rvec - normal_vs * dot(rvec, normal_vs));
    float3 bitangent = cross(tangent, normal_vs);
    float3x3 tbn = make_f3x3_cols(tangent, bitangent, normal_vs);
    uint skip_samples = 0;
    for (uint i = 0; i < SSAO_SAMPLE_COUNT; i++) {
      float3 sample_pos =
          pos_vs + mul(tbn, Get(kernels)[i].xyz) * SSAO_SAMPLE_RADIUS;

      float4 offset = mul((camera_projection), float4(sample_pos, 1.0));
      offset.xyz /= offset.w;
      offset.xy = offset.xy * 0.5 + 0.5;
      offset.y = 1.0 - offset.y;
      // skip pixel outside screen
      if (AnyGreaterThan(offset.xy, float2(1.0, 1.0)) ||
          AnyLessThan(offset.xy, float2(0.0, 0.0))) {
        skip_samples++;
        continue;
      }
      float sample_z =
          SampleTex2D(Get(depth_tex), default_sampler, offset.xy).r;
      // we need to compare depth in linear space
      float linearZ =
          ReconstructWorldPos(Get(camera_inv_projection), sample_z, offset.xy)
              .z;
      // occluded
      float range_falloff = SmoothStep(
          0.0, 1.0,
          SSAO_SAMPLE_RADIUS /
              abs(linearZ -
                  pos_vs.z)); // closer samples contribute more occlusion
      if (abs(linearZ - pos_vs.z) > SSAO_SAMPLE_RADIUS)
        continue;
      if (linearZ >= sample_pos.z + SSAO_BIAS) {
        nom += 1.0 * range_falloff;
      }
    }

    float denom = SSAO_SAMPLE_COUNT - skip_samples;
    return 1.0f - nom / denom;
}

float2 RotateDirection(float2 Dir, float2 CosSin) {
    return float2(Dir.x * CosSin.x - Dir.y * CosSin.y,
                  Dir.x * CosSin.y + Dir.y * CosSin.x);
}

float Falloff(float DistanceSquare) {
    // 1 scalar mad instruction
    return DistanceSquare * g_NegInvR2 + 1.0;
}

float ComputeAO(float3 pos_vs, float3 normal_vs, float3 sample_pos_vs) {
    float3 v = sample_pos_vs - pos_vs;
    float vov = dot(v, v);
    float nov = dot(normal_vs, v) * sqrt(vov);
    return saturate(nov) * saturate(Falloff(vov));
}


float HBAO(float2 uv, uint2 xy, float3 pos_vs, float3 normal_vs) {
    // cos, sin, rand
    float2 noiseUv = uv * Get(noiseScale).xy;
    float3 jitter =
        SampleTex2D(Get(hbao_rand_tex), default_sampler, noiseUv).xyz;
    float radius_pixel =
        Get(g_RadiusToScreen) /
        abs(pos_vs.z); // step size will decrease when p becomes far
    float stepSize = radius_pixel / (NUM_MARCH_STEPS + 1);

    float alpha = 2 * _PI / NUM_MARCH_DIRECTIONS;

    float ao = 0.0f;
    uint skip_samples = 0;
    for (uint i = 0; i < NUM_MARCH_DIRECTIONS; i++) {
      float angle = i * alpha;
      float2 start_dir = normalize(jitter.xy);
      float2 dir = RotateDirection(start_dir, float2(cos(angle), sin(angle)));
      float p = jitter.z * stepSize + 1.0f;

      for (uint j = 0; j < NUM_MARCH_STEPS; j++) {
        float2 offsetUv = round(p * dir) / (Get(resolution.xy)) + uv;
        // skip samples outside screen
        if (AnyGreaterThan(offsetUv.xy, float2(1.0, 1.0)) ||
            AnyLessThan(offsetUv.xy, float2(0.0, 0.0))) {
          skip_samples++;
          continue;
        }
        float depth = SampleTex2D(Get(depth_tex), default_sampler, offsetUv).r;
        float3 sample_vs =
            ReconstructWorldPos(Get(camera_inv_projection), depth, offsetUv);
        p += stepSize;
        ao += ComputeAO(pos_vs, normal_vs, sample_vs);
      }
    }

    ao *= HBAO_SCALE / (NUM_MARCH_DIRECTIONS * NUM_MARCH_STEPS - skip_samples);
    return saturate(1.0 - ao * 2.0);
}



NUM_THREADS(8, 8, 1)
void CS_MAIN(SV_DispatchThreadID(uint3) threadID) 
{
    INIT_MAIN;

    uint2 _resolution = Get(resolution.xy) - uint2(1.0, 1.0);

    if (threadID.x > _resolution.x || threadID.y > _resolution.y) {
      RETURN();
    }

    float2 uv = float2(threadID.xy) / float2(_resolution);

    float depth = LoadTex2D0(Get(depth_tex), threadID.xy, 0).r;
    float3 pos_vs = ReconstructWorldPos(Get(camera_inv_projection), depth, uv);

    float3 normal_ws = LoadTex2D0(Get(normal_tex), threadID.xy, 0).xyz;

    float3 normal_vs = normalize(
        mul(Get(camera_view), float4(normal_ws, 0.0))).xyz); // view space normal

    float ao = 1.0f;
    if (aoMethod == AO_METHOD_SSAO) {
      ao = SSAO(pos_vs, normal_vs, uv);
    } else if (aoMethod == AO_METHOD_HBAO) {
      ao = HBAO(uv, threadID.xy,
                       pos_vs, normal_vs);
    }
    float4 out_color = float4(ao, 0.0, 0.0, 0.0);

    Write2D(Get(ao_factor_tex), threadID.xy, out_color);

    RETURN();
}
