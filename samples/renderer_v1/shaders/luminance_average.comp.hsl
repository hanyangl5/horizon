// codes are modified from https://alextardif.com/HistogramLuminance.html

#include "include/common/luminance.h"
#include "include/postprocess/histogram.h"

RES(RWTex2D(float4), color_image, UPDATE_FREQ_PER_FRAME, u0, binding = 0);
RES(RWBuffer(uint), histogram, UPDATE_FREQ_PER_FRAME, u2, binding = 2);
RES(RWBuffer(float), adaptedLuminance, UPDATE_FREQ_PER_FRAME, u2, binding = 4);

CBUFFER(LuminanceHistogramConstants, UPDATE_FREQ_PER_FRAME, b0, binding = 3) 
{
  DATA(uint2, resolution, None);
  DATA(uint, pixelCount, None);
  DATA(float, maxLuminance, None);
  DATA(float, timeCoeff, None);
};

GroupShared(float, histogramShared[GROUP_SIZE]);

NUM_THREADS(16, 16, 1)
void CS_MAIN(SV_DispatchThreadID(uint3) threadID, SV_GroupIndex(uint) localIndex) 
{
  INIT_MAIN;

  if (threadID.x >= resolution.x || threadID.y >= resolution.y) {
    RETURN();
  }
  float4 color = LoadRWTex2D(Get(color_image), threadID.xy);
  // Get the count from the histogram buffer
  float countForThisBin = float(histogram[localIndex]);
  histogramShared[localIndex] = countForThisBin * float(localIndex);

  GroupMemoryBarrier();

  // This loop will perform a weighted count of the luminance range

  for (uint cutoff = (GROUP_SIZE >> 1); cutoff > 0; cutoff >>= 1) {
    if (uint(localIndex) < cutoff) {
      histogramShared[localIndex] += histogramShared[localIndex + cutoff];
    }

    GroupMemoryBarrier();
  }

  if (localIndex == 0) {
    float averageLuminance =
        (histogramShared[0] / max(pixelCount - float(countForThisBin), 1.0)) -
        1.0;

    // Map from our histogram space to actual luminance
    averageLuminance = averageLuminance * maxLuminance / 255.0f;
    // interpolate average luminace with last frame
    float luminancePrev = adaptedLuminance[0];
    float adaptedLum =
        luminancePrev + (averageLuminance - luminancePrev) * timeCoeff;
    adaptedLuminance[0] = adaptedLum;
  }

  RETURN();
}
